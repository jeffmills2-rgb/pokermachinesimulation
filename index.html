<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Probability Spinner Simulator (Centered + Wheel)</title>
<style>
  :root {
    --fg:#111; --muted:#555; --border:#000; --accent:#1b5e20; --warn:#b00020;
    --table-w: 640px; /* adjust table width if desired */
  }

  /* Center the whole program */
  .app { width: min(100%, 980px); margin: 0 auto; padding: 0 12px; }

  body { font-family: Arial, sans-serif; color:var(--fg); margin:24px 0; line-height:1.35; }
  h1 { font-size: 34px; margin: 0 0 16px; }
  h3 { font-size: 22px; margin: 18px 0 8px; }
  .hidden { display:none; }

  input, button, label { font-size:18px; }
  input[type="number"], input[type="text"], input[type="password"] {
    padding:10px 12px; border:2px solid #000; border-radius:12px;
    height:44px; line-height:44px; box-sizing: border-box; background:#fff;
  }
  button { padding:10px 16px; margin:10px 12px 0 0; border:3px solid #000; border-radius:12px; background:#fff; }
  .note { color:var(--muted); font-size:14px; }
  .warn { color: var(--warn); font-size:16px; margin-top:8px; }
  .row { display:flex; gap:18px; align-items:center; flex-wrap:wrap; margin:12px 0; }
  .controls { margin-top:14px; }

  /* Rounded, thick-bordered table */
  .table-wrap { width: min(100%, var(--table-w)); }
  table { width:100%; border-collapse: separate; border-spacing: 0;
          border-radius: 18px; overflow: hidden; background:#fff; }
  th, td { border:4px solid var(--border); padding:16px; text-align:center; }
  th { background:#f4f6f9; font-size:22px; font-weight:700; }
  td input { width:100%; margin: 2px 0; }
  tfoot td { border: none; padding: 12px 0 0; }

  .stats { margin-top:12px; font-size:16px; }
  .stats strong { color:#000; }
  canvas { border:3px solid #000; margin-top:18px; max-width:100%; height:auto; border-radius:12px; }
  .ok { color:var(--accent); font-weight:700; }

  .pwbox { display:flex; gap:10px; align-items:center; margin-top:8px; flex-wrap:wrap; }
  .pwbox input { width: 240px; }

  /* Wheel layout */
  .wheel-wrap { display:flex; justify-content:center; margin-top:12px; }
  #wheelCanvas { border-radius: 50%; border:3px solid #000; background:#fff; }
</style>
</head>
<body>
  <div class="app">
    <h1>Welcome to the Probability Spinner Simulator</h1>

    <div id="menuScreen">
      <div class="row">
        <label for="costInput">Cost per spin:</label>
        <input type="number" id="costInput" min="0.01" step="0.01" value="25">
        <label for="balanceInput">Starting balance:</label>
        <input type="number" id="balanceInput" min="0.01" step="0.01" value="10000">
      </div>

      <h3>Enter your prize amounts and chance of winning in the box below</h3>

      <div class="table-wrap">
        <table id="prizeTable" aria-label="Prize and percentage table">
          <thead>
            <tr>
              <th>Prize</th>
              <th>Percentage chance</th>
              <th style="width:140px;">Row</th>
            </tr>
          </thead>
          <tbody><!-- rows inserted by JS --></tbody>
          <tfoot>
            <tr>
              <td colspan="3" class="note">Percentages must total 100%.</td>
            </tr>
          </tfoot>
        </table>
      </div>

      <div id="sumWarnAboveButtons" class="warn hidden">% does not total 100</div>

      <button id="addRowBtn">Add row</button>

      <div class="controls">
        <button id="revealKeyBtn">Reveal key information</button>
        <button id="submitButton">Submit</button>
        <button id="resetButton">Reset</button>
      </div>

      <!-- Password + key info -->
      <div id="pwGate" class="hidden">
        <div class="pwbox">
          <label for="pwInput"><strong>Password:</strong></label>
          <input type="password" id="pwInput" placeholder="Enter password">
          <button id="pwCheckBtn">Unlock</button>
          <span id="pwMsg" class="note"></span>
        </div>
      </div>

      <div id="keyInfo" class="hidden" aria-live="polite">
        <div id="keyWarn" class="warn hidden">% does not total 100</div>

        <div id="keyStatsBlock">
          <div class="row" style="margin-top:14px;">
            <span><strong>Average prize:</strong> <input type="text" id="avgPrize" readonly style="width:160px;"></span>
            <span><strong>Average RTP:</strong> <input type="text" id="avgRTP" readonly style="width:160px;"></span>
          </div>
          <div class="stats" id="theoryStats"></div>
        </div>
      </div>
    </div>

    <div id="spinnerScreen" class="hidden">
      <div class="controls">
        <button id="backButton">Back to Menu</button>
        <button id="spinButton">Spin</button>
        <button id="autoRunButton">Run 500 Trials</button>
        <button id="stopButton" disabled>Stop</button>
      </div>

      <!-- Spinner wheel -->
      <div class="wheel-wrap">
        <canvas id="wheelCanvas" width="420" height="420"></canvas>
      </div>

      <p id="resultText" class="ok"></p>
      <div class="row">
        <label>Balance:</label>
        <input type="text" id="balanceBox" readonly style="width:160px;">
        <span id="costInfo" class="note"></span>
      </div>

      <canvas id="balanceGraph" width="900" height="420"></canvas>
      <div class="note">Graph shows balance after each spin. Zero line is shown if within range.</div>
    </div>
  </div>

  <audio id="spinSound" src="https://www.soundjay.com/button/sounds/button-16.mp3"></audio>

<script>
/* ---------- State ---------- */
let values = [], probs = [], cdf = [];
let balance = 0, cost = 25, spinCount = 0;
let balanceHistory = [];
let autoRunInterval = null;
let insufficientFundsShown = false;
let autorunning = false;

/* Wheel state */
let wheelSegments = [];   // [{start,end,label,color}]
let rotation = 0;         // current wheel rotation (radians)
let spinning = false;

/* ---------- Elements ---------- */
const tableBody = document.querySelector('#prizeTable tbody');
const addRowBtn = document.getElementById('addRowBtn');

const revealKeyBtn = document.getElementById('revealKeyBtn');
const pwGate = document.getElementById('pwGate');
const pwInput = document.getElementById('pwInput');
const pwCheckBtn = document.getElementById('pwCheckBtn');
const pwMsg = document.getElementById('pwMsg');
const keyInfo = document.getElementById('keyInfo');
const keyWarn = document.getElementById('keyWarn');
const sumWarnAboveButtons = document.getElementById('sumWarnAboveButtons');
const keyStatsBlock = document.getElementById('keyStatsBlock');

const submitButton = document.getElementById('submitButton');
const resetButton = document.getElementById('resetButton');
const backButton = document.getElementById('backButton');
const spinButton = document.getElementById('spinButton');
const autoRunButton = document.getElementById('autoRunButton');
const stopButton = document.getElementById('stopButton');

const avgPrizeBox = document.getElementById('avgPrize');
const avgRTPBox = document.getElementById('avgRTP');
const theoryStats = document.getElementById('theoryStats');

const resultText = document.getElementById('resultText');
const balanceBox = document.getElementById('balanceBox');
const costInfo = document.getElementById('costInfo');

const costInput = document.getElementById('costInput');
const balanceInput = document.getElementById('balanceInput');

const canvas = document.getElementById('balanceGraph');
const ctx = canvas.getContext('2d');
const spinSound = document.getElementById('spinSound');

/* Wheel canvas */
const wheelCanvas = document.getElementById('wheelCanvas');
const wctx = wheelCanvas.getContext('2d');
const W = wheelCanvas.width, H = wheelCanvas.height;
const CX = W/2, CY = H/2;
const R = Math.min(W, H)/2 - 24; // wheel radius

/* ---------- Helpers ---------- */
function fmtMoney(n){ return Number(n).toFixed(2); }
function fmtPct(n){ return (Number(n)*100).toFixed(2) + "%"; }
const TAU = Math.PI*2;
const modTau = a => ((a % TAU) + TAU) % TAU;
function easeOutCubic(t){ return 1 - Math.pow(1 - t, 3); }

function addRow(v = "", p = "") {
  const tr = document.createElement('tr');
  tr.innerHTML = `
    <td><input type="number" step="0.01" class="prize" value="${v}" aria-label="Prize"></td>
    <td><input type="number" step="0.01" min="0" max="100" class="pct" value="${p}" aria-label="Percentage chance"></td>
    <td><button class="delRowBtn" style="width:110px;">Delete</button></td>
  `;
  tr.querySelector('.delRowBtn').addEventListener('click', () => {
    tr.remove(); autoRefreshKeyInfo();
  });
  tr.querySelector('.prize').addEventListener('input', autoRefreshKeyInfo);
  tr.querySelector('.pct').addEventListener('input', autoRefreshKeyInfo);
  tableBody.appendChild(tr);
}

function getRows(){
  const rows = [...tableBody.querySelectorAll('tr')];
  return {
    prizes: rows.map(r => Number(r.querySelector('.prize').value)),
    pcts:   rows.map(r => Number(r.querySelector('.pct').value))
  };
}

function percentagesSumTo100(){
  const { pcts } = getRows();
  if (pcts.length === 0) return false;
  if (pcts.some(p => Number.isNaN(p) || p < 0)) return false;
  const total = pcts.reduce((a,b)=>a+b,0);
  return Math.abs(total - 100) <= 0.001;
}

function buildDistributionFromTable(){
  const {prizes, pcts} = getRows();
  values = prizes;
  probs  = pcts.map(x => x/100);
  cdf = [];
  let c = 0; for (const p of probs) { c += p; cdf.push(c); }
  if (cdf.length) cdf[cdf.length-1] = 1;
}

function expectedPrizeWeighted(){ return values.reduce((s,v,i)=> s + v*probs[i], 0); }

/* ---------- Key info rendering ---------- */
function renderKeyStats(){
  const costPer = Number(costInput.value);
  if (Number.isNaN(costPer) || costPer <= 0) return;

  const avg = expectedPrizeWeighted();
  const rtp = avg / costPer;
  const ev = avg - costPer;
  const houseEdge = 1 - rtp;

  const mean = avg;
  const variance = values.reduce((s,v,i)=> s + probs[i]*(v-mean)*(v-mean), 0);
  const stdev = Math.sqrt(variance);
  const sorted = [...values].sort((a,b)=>a-b);
  const median = (sorted.length % 2 ? sorted[(sorted.length-1)/2] : (sorted[sorted.length/2-1]+sorted[sorted.length/2])/2);

  avgPrizeBox.value = fmtMoney(avg);
  avgRTPBox.value   = fmtPct(rtp);
  theoryStats.innerHTML =
    `<div><strong>Expected change/spin:</strong> ${fmtMoney(ev)} &nbsp; `
    + `<strong>House edge:</strong> ${fmtPct(houseEdge)}</div>`
    + `<div>Min: ${fmtMoney(Math.min(...values))} &nbsp; `
    + `Median: ${fmtMoney(median)} &nbsp; `
    + `Max: ${fmtMoney(Math.max(...values))} &nbsp; `
    + `Std dev: ${fmtMoney(stdev)}</div>`;
}

function clearKeyStats(){
  avgPrizeBox.value = "";
  avgRTPBox.value = "";
  theoryStats.textContent = "";
}

function showKeyInfo(){
  const ok = percentagesSumTo100();
  sumWarnAboveButtons.classList.toggle('hidden', ok);
  keyWarn.classList.toggle('hidden', ok);

  if (!ok) {
    clearKeyStats();
    keyStatsBlock.classList.add('hidden');
    return;
  }

  keyStatsBlock.classList.remove('hidden');
  buildDistributionFromTable();
  renderKeyStats();
  keyInfo.classList.remove('hidden');
}

/* auto-refresh handler for any input change */
function autoRefreshKeyInfo(){
  if (!pwGate.classList.contains('hidden') || !keyInfo.classList.contains('hidden')) {
    showKeyInfo();
  } else {
    const ok = percentagesSumTo100();
    sumWarnAboveButtons.classList.toggle('hidden', ok);
  }
}

/* ---------- Wheel drawing & animation ---------- */
const palette = [
  "#f44336","#e91e63","#9c27b0","#673ab7","#3f51b5","#2196f3",
  "#03a9f4","#00bcd4","#009688","#4caf50","#8bc34a","#cddc39",
  "#ffeb3b","#ffc107","#ff9800","#ff5722"
];

function buildWheelSegments(){
  wheelSegments = [];
  let a = 0;
  for (let i=0;i<probs.length;i++){
    const span = probs[i]*Math.PI*2;
    const start = a;
    const end = a + span;
    a = end;
    wheelSegments.push({
      start, end,
      label: fmtMoney(values[i]),
      color: palette[i % palette.length]
    });
  }
  rotation = modTau(rotation); // keep clean
}

function drawWheel(){
  // clear
  wctx.clearRect(0,0,W,H);

  // segments
  wheelSegments.forEach(seg=>{
    wctx.beginPath();
    wctx.moveTo(CX,CY);
    wctx.fillStyle = seg.color;
    wctx.arc(CX,CY,R, seg.start + rotation, seg.end + rotation);
    wctx.closePath();
    wctx.fill();
    wctx.strokeStyle = "#000";
    wctx.lineWidth = 2;
    wctx.stroke();
  });

  // labels (skip very tiny slices)
  wctx.fillStyle = "#000";
  wctx.font = "16px Arial";
  wctx.textAlign = "center";
  wctx.textBaseline = "middle";
  wheelSegments.forEach(seg=>{
    const span = seg.end - seg.start;
    if (span < 0.06) return; // ~3.4°—too tiny to label
    const mid = (seg.start + seg.end)/2 + rotation;
    const rx = CX + Math.cos(mid) * (R * 0.62);
    const ry = CY + Math.sin(mid) * (R * 0.62);
    wctx.fillText(seg.label, rx, ry);
  });

  // center cap
  wctx.beginPath();
  wctx.arc(CX,CY, 20, 0, Math.PI*2);
  wctx.fillStyle = "#fff";
  wctx.fill();
  wctx.strokeStyle="#000";
  wctx.lineWidth=2;
  wctx.stroke();

  // pointer (top)
  drawPointer();
}

function drawPointer(){
  const tipX = CX, tipY = CY - R - 8;
  const baseLx = CX - 16, baseLy = CY - R - 42;
  const baseRx = CX + 16, baseRy = CY - R - 42;
  wctx.beginPath();
  wctx.moveTo(tipX, tipY);
  wctx.lineTo(baseLx, baseLy);
  wctx.lineTo(baseRx, baseRy);
  wctx.closePath();
  wctx.fillStyle = "#000";
  wctx.fill();
  wctx.strokeStyle = "#000";
  wctx.lineWidth = 2;
  wctx.stroke();
}

function segmentMidAngle(idx){
  const seg = wheelSegments[idx];
  return (seg.start + seg.end)/2;
}

function animateSpinToIndex(idx, onDone){
  if (!wheelSegments.length) { if (onDone) onDone(); return; }
  spinning = true;
  spinButton.disabled = true;
  autoRunButton.disabled = true;
  backButton.disabled = true;

  const pointerAngle = -Math.PI/2; // top
  const midBase = segmentMidAngle(idx); // base geometry (no rotation)
  const deltaToAlign = modTau(pointerAngle - (midBase + rotation)); // how much more to rotate to center target
  const extraTurns = 4; // full spins for drama
  const finalRotation = rotation + extraTurns*Math.PI*2 + deltaToAlign;

  const duration = 3000; // ms
  const start = performance.now();
  const startRot = rotation;
  function step(ts){
    const t = Math.min(1, (ts - start) / duration);
    const eased = easeOutCubic(t);
    rotation = startRot + (finalRotation - startRot) * eased;
    drawWheel();
    if (t < 1) requestAnimationFrame(step);
    else {
      rotation = modTau(finalRotation);
      drawWheel();
      spinning = false;
      spinButton.disabled = false;
      autoRunButton.disabled = false;
      backButton.disabled = false;
      if (onDone) onDone();
    }
  }
  requestAnimationFrame(step);
}

/* ---------- Graph ---------- */
function drawGraph(animatedIndex = balanceHistory.length - 1){
  const Wg = canvas.width, Hg = canvas.height;
  const left = 70, right = 24, top = 46, bottom = 46;
  const plotW = Wg - left - right, plotH = Hg - top - bottom;

  ctx.clearRect(0,0,Wg,Hg);
  ctx.font = "22px Arial"; ctx.textAlign="center"; ctx.fillStyle="#000";
  ctx.fillText("Balance over time", Wg/2, 32);

  ctx.strokeStyle = "#000"; ctx.lineWidth = 3; ctx.strokeRect(left, top, plotW, plotH);

  const minBal = Math.min(...balanceHistory), maxBal = Math.max(...balanceHistory);
  let yMin = Math.min(minBal, 0), yMax = Math.max(maxBal, 1);
  if (yMax - yMin < 1) yMax = yMin + 1;

  ctx.font = "14px Arial"; ctx.textAlign="right"; ctx.fillStyle="#000";
  for (let i=0;i<=5;i++){
    const t=i/5, yVal = yMax - t*(yMax-yMin), y = top + t*plotH;
    ctx.fillText(yVal.toFixed(0), left-8, y+4);
    ctx.strokeStyle = "#ddd"; ctx.lineWidth=1.5; ctx.beginPath(); ctx.moveTo(left,y); ctx.lineTo(left+plotW,y); ctx.stroke();
  }

  if (yMin < 0 && yMax > 0){
    const t0 = (yMax-0)/(yMax-yMin), y0 = top + t0*plotH;
    ctx.strokeStyle="#999"; ctx.setLineDash([6,5]); ctx.lineWidth=2;
    ctx.beginPath(); ctx.moveTo(left,y0); ctx.lineTo(left+plotW,y0); ctx.stroke(); ctx.setLineDash([]);
  }

  ctx.textAlign="center";
  const n = balanceHistory.length - 1;
  for (let i=0;i<=10;i++){
    const idx = Math.round(n*i/10), x = left + plotW*(idx/Math.max(1,n));
    ctx.fillText(idx, x, top+plotH+22);
    ctx.strokeStyle="#eee"; ctx.beginPath(); ctx.moveTo(x,top); ctx.lineTo(x,top+plotH); ctx.stroke();
  }

  const xAt = i => left + plotW*(i/Math.max(1,n));
  const yAt = v => top + ((yMax - v)/(yMax - yMin))*plotH;

  ctx.strokeStyle = "#1e88e5"; ctx.lineWidth=3; ctx.beginPath();
  for (let i=0;i<=animatedIndex;i++){ const x=xAt(i), y=yAt(balanceHistory[i]); if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); }
  ctx.stroke();

  ctx.fillStyle="#e53935";
  for (let i=0;i<=animatedIndex;i++){ const x=xAt(i), y=yAt(balanceHistory[i]); ctx.beginPath(); ctx.arc(x,y,3,0,Math.PI*2); ctx.fill(); }
}

function animateGraph(){
  let i=0, target=balanceHistory.length-1;
  const step=()=>{ drawGraph(i); if(i<target){ i++; requestAnimationFrame(step);} };
  step();
}

/* ---------- Sampling & run control ---------- */
function weightedPick(){
  const r = Math.random();
  let lo=0, hi=cdf.length-1, ans=hi;
  while (lo<=hi){ const mid=(lo+hi)>>1; if (r<=cdf[mid]){ ans=mid; hi=mid-1; } else lo=mid+1; }
  return ans;
}
function setAutorun(run){
  autorunning = run;
  autoRunButton.disabled = run; spinButton.disabled = run || spinning; stopButton.disabled = !run;
}

function settleSpin(idx, win, manual){
  balance -= Number(costInput.value);
  balance += win;
  spinCount++;
  balanceHistory.push(balance);
  resultText.textContent = `Spin #${spinCount}: won ${fmtMoney(win)} (p≈${fmtPct(probs[idx])})`;
  balanceBox.value = fmtMoney(balance);
  if (manual) animateGraph(); else drawGraph();
}

function spin(manual=true){
  if (spinning) return false;
  const c = Number(costInput.value);
  if (balance < c){
    if(!insufficientFundsShown && manual) alert("Insufficient funds");
    insufficientFundsShown = true;
    return false;
  }
  if (manual){ try{ spinSound.currentTime=0; spinSound.play(); }catch(e){} }

  const idx = weightedPick();
  const win = values[idx];

  if (manual){
    animateSpinToIndex(idx, ()=> settleSpin(idx, win, true));
  } else {
    settleSpin(idx, win, false);
  }
  return true;
}

function autoRunTrials(total=500, speed=20){
  let ct=0; clearInterval(autoRunInterval); setAutorun(true);
  autoRunInterval = setInterval(()=>{
    if (ct>=total || balance < Number(costInput.value)){
      clearInterval(autoRunInterval); setAutorun(false);
      if (balance < Number(costInput.value) && !insufficientFundsShown) alert("Insufficient funds");
      insufficientFundsShown = balance < Number(costInput.value);
      return;
    }
    spin(false); ct++;
  }, speed);
}
function stopAutoRun(){ clearInterval(autoRunInterval); setAutorun(false); }

/* ---------- Navigation / setup ---------- */
function toSpinnerScreen(){
  document.getElementById('menuScreen').classList.add('hidden');
  document.getElementById('spinnerScreen').classList.remove('hidden');
  buildWheelSegments();
  drawWheel();
}
function toMenuScreen(){
  document.getElementById('spinnerScreen').classList.add('hidden');
  document.getElementById('menuScreen').classList.remove('hidden');

  /* NEW: Re-lock key info when returning to menu */
  keyInfo.classList.add('hidden');     // hide revealed info
  pwGate.classList.add('hidden');      // hide the password strip
  pwInput.value = "";                  // clear the password field
  pwMsg.textContent = "";              // clear status message
}

function submit(){
  if (!percentagesSumTo100()){
    sumWarnAboveButtons.classList.remove('hidden');
    keyWarn.classList.remove('hidden');
    keyStatsBlock.classList.add('hidden');
    return;
  }

  buildDistributionFromTable();

  balance = Number(balanceInput.value);
  cost    = Number(costInput.value);
  if (Number.isNaN(balance) || Number.isNaN(cost) || balance<=0 || cost<=0){
    alert("Please enter valid positive numbers for balance and cost per spin.");
    return;
  }

  showKeyInfo();

  balanceHistory = [balance]; spinCount = 0; insufficientFundsShown = false;
  toSpinnerScreen();
  balanceBox.value = fmtMoney(balance);
  costInfo.textContent = `Cost per spin: ${fmtMoney(cost)}`;
  drawGraph();
}

function resetAll(){
  tableBody.innerHTML = '';
  addRow(0, 60); addRow(5, 30); addRow(45, 10); // defaults
  costInput.value = 25;
  balanceInput.value = 10000;

  keyInfo.classList.add('hidden');
  pwGate.classList.add('hidden');
  pwInput.value = "";
  pwMsg.textContent = "";
  clearKeyStats();
  sumWarnAboveButtons.classList.add('hidden');

  rotation = 0; wheelSegments = [];
  drawWheel();
}

/* ---------- Events ---------- */
addRowBtn.addEventListener('click', ()=> { addRow(); autoRefreshKeyInfo(); });

tableBody.addEventListener('input', autoRefreshKeyInfo);
costInput.addEventListener('input', autoRefreshKeyInfo);

revealKeyBtn.addEventListener('click', ()=>{
  showKeyInfo();
  pwGate.classList.remove('hidden');
  keyInfo.classList.add('hidden');
  pwInput.focus();
});
pwCheckBtn.addEventListener('click', ()=>{
  if (pwInput.value === "Piis3.14"){
    keyInfo.classList.remove('hidden');
    pwMsg.textContent = "Unlocked."; pwMsg.style.color = "#1b5e20";
    autoRefreshKeyInfo();
  } else {
    pwMsg.textContent = "Incorrect password."; pwMsg.style.color = "#b00020";
  }
});
pwInput.addEventListener('keydown', (e)=>{ if (e.key === "Enter") pwCheckBtn.click(); });

submitButton.addEventListener('click', submit);
resetButton.addEventListener('click', resetAll);
backButton.addEventListener('click', ()=>{ stopAutoRun(); toMenuScreen(); });
spinButton.addEventListener('click', ()=>spin(true));
autoRunButton.addEventListener('click', ()=>autoRunTrials());
stopButton.addEventListener('click', stopAutoRun);

/* Initial rows + initial blank wheel draw */
resetAll();
buildWheelSegments();
drawWheel();
</script>
</body>
</html>
